package de.dimond.tippspiel.model.mapper

import de.dimond.tippspiel.model._

import net.liftweb.mapper._
import net.liftweb.common._

import org.scala_tools.time.Imports._
import java.util.Date

object DbSpecialTip extends DbSpecialTip with LongKeyedMetaMapper[DbSpecialTip] with MetaSpecialTip {
  def updatePoints(special: Special, finalAnswerId: Int): Boolean = false
  def answerForUser(user: User, special: Special) = find(By(_userId, user.id), By(_specialId, special.id))
  def answersForUser(user: User, specials: Seq[Special]): Map[Special, SpecialTip] =  {
    val specialTips = findAll(By(_userId, user.id), ByList(_specialId, specials.map(_.id)))
    val tipMap = specialTips.map(tip => (tip._specialId.is, tip)).toMap
    val seq = for {
      special <- specials
      tip <- tipMap.get(special.id)
    } yield (special -> tip)
    seq.toMap
  }
  def saveForUser(user: User, special: Special, answerId: Int): Boolean = {
    if (DateTime.now > special.finalAnswerTime) {
      return false
    }
    val box = find(By(_userId, user.id), By(_specialId, special.id))
    val specialAnswer = box openOr DbSpecialTip.create._userId(user.id)._specialId(special.id)
    specialAnswer._answerId(answerId)
    specialAnswer._submissionTime(new Date())
    val result = specialAnswer.save()
    if (result && box.isEmpty) {
      TipCountManager ! TipCountManager.SetDirty(user)
    }
    return result
  }
  def numberPlacedForUser(user: User): Int = {
    count(By(_userId, user.id)).toInt
  }
  def totalCount = count
}

class DbSpecialTip extends SpecialTip with LongKeyedMapper[DbSpecialTip] with IdPK {
  def getSingleton = DbSpecialTip

  protected object _userId extends MappedLong(this) {
    override def dbIndexed_? = true
  }
  protected object _specialId extends MappedLong(this) {
    override def dbIndexed_? = true
  }
  protected object _answerId extends MappedInt(this)
  protected object _submissionTime extends MappedDateTime(this)
  protected object _points extends MappedInt(this)

  override def userId = _userId.is
  override def special = Special.forId(_specialId.is).get
  override def answerId = _answerId.is
  override def submissionTime = new DateTime(_submissionTime.is)
}

object DbSpecialResult extends DbSpecialResult with LongKeyedMetaMapper[DbSpecialResult] with MetaSpecialResult {
  var results: Map[Special, Option[SpecialResult]] = Map()

  override protected def doSave(special: Special, answerId: Option[Int]): Box[SpecialResult] = {
    def save(sr: DbSpecialResult) = {
      sr._specialId(special.id)
      answerId match {
        case Some(i) => sr._answerId(i)
        case None => sr._answerId(-1)
      }
      if (sr.save()) {
        results += special -> Some(sr)
        Full(sr)
      } else {
        Failure("Failed to save special result!")
      }
    }
    find(By(_specialId, special.id)) match {
      case Full(sr) => save(sr)
      case f: Failure => f
      case Empty => save(DbSpecialResult.create)
    }
  }


  def forSpecial(special: Special): Box[SpecialResult] = {
    results.get(special) match {
      case None => {
        find(By(_specialId, special.id)) match {
          case Full(result) => {
            results += special -> Some(result)
            Full(result)
          }
          case f: Failure => f
          case Empty => {
            results += special -> None
            Empty
          }
        }
      }
      case Some(ro) => Box(ro)
    }
  }
}

class DbSpecialResult extends SpecialResult with LongKeyedMapper[DbSpecialResult] {
  def getSingleton = DbSpecialResult

  override def primaryKeyField = _specialId

  protected object _specialId extends MappedLongIndex(this) {
    override def writePermission_? = true
    override def dbAutogenerated_? = false
  }
  protected object _answerId extends MappedInt(this)

  override def special = Special.forId(_specialId.is).get
  override def answerId = _answerId.is
}
